# QuickSort (ჰოარის განყოფილება - Hoare Partition Scheme)
# დროითი სირთულე:
#   საშუალო: O(n log n)
#   უარეს შემთხვევაში: O(n²) (თუ პივოტი ცუდად არის შერჩეული)
# მეხსიერების სირთულე:
#   O(log n) — რეკურსიული ფონის გამოყენებით

def partition(arr, low, high):
    pivot = arr[low]
    i = low - 1
    j = high + 1

    while True:
        i += 1
        while arr[i] < pivot:
            i += 1

        j -= 1
        while arr[j] > pivot:
            j -= 1

        if i >= j:
            return j

        # გაცვლა ინდექსებზე i და j
        arr[i], arr[j] = arr[j], arr[i]

def quickSort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quickSort(arr, low, pi)
        quickSort(arr, pi + 1, high)

def printArray(arr):
    for i in arr:
        print(i, end=" ")
    print()

if __name__ == "__main__":
    arr = [8, 4, 7, 9, 3, 10, 5]
    print("მორიგი მასივი (Original array):")
    printArray(arr)

    quickSort(arr, 0, len(arr) - 1)

    print("დალაგებული მასივი (Sorted array):")
    printArray(arr)

# ==============================================================================
# QuickSort (ლომუტოს განყოფილება - Lomuto Partition Scheme)
# დროითი სირთულე:
#   საშუალო: O(n log n)
#   უარეს შემთხვევაში: O(n²)
# მეხსიერების სირთულე:
#   O(log n)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1

    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            swap(arr, i, j)

    swap(arr, i + 1, high)
    return i + 1

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

if __name__ == "__main__":
    arr = [10, 7, 8, 9, 1, 5]
    print("მორიგი მასივი (Original array):", arr)

    quick_sort(arr, 0, len(arr) - 1)

    print("დალაგებული მასივი (Sorted array):", arr)

# ==============================================================================
# 1. ორი რიცხვის გადამრავლება - იტერაციული მიდგომა
# Time complexity: O(b) — ბ-ის მნიშვნელობაზე არის დამოკიდებული
# Space complexity: O(1) — დამატებითი მეხსიერება თითქმის არ გამოიყენება

def mult_iter(a,b):
    res = 0
    while b > 0:
        res += a
        b -= 1
    return res
print(mult_iter(30,11))

# ==============================================================================
# 2. ორი რიცხვის გადამრავლება - რეკურსიული მიდგომა
# Time complexity: O(b) — რეკურსიული ზარების რაოდენობა ბ-ის მნიშვნელობაზეა დამოკიდებული
# Space complexity: O(b) — რეკურსიული ფონის განთავსებისთვის

def mult_rec(a,b):
    if b == 1:
        return a
    else:
        return a+ mult_rec(a, b-1)
    
print(mult_rec(15,7))

# ==============================================================================
# 3. ფაქტორიალი - რეკურსიული მიდგომა
# Time complexity: O(n) — რეკურსიის სიღრმე n-ის შესაბამისად
# Space complexity: O(n) — რეკურსიული ფონის მეხსიერება

def fact(n):
    if n == 1:
        return 1
    else:
        return n*fact(n-1)
    
print(fact(5))

# ==============================================================================
# 4. ფაქტორიალი - იტერაციული მიდგომა
# Time complexity: O(n) — ერთჯერადი ციკლი n-ზე
# Space complexity: O(1) — ცვლადის შენახვა, სტეკი არ გამოიყენება

def fact_iter(n):
    prod = 1
    for i in range(1, n+1):
        prod *= i 
    return prod

print(fact_iter(6))

# ==============================================================================
# 5. ჰანოის კოშკები
# Time complexity: O(2^n) — ყოველი დისკისთვის ექსპონენციალური ზრდა
# Space complexity: O(n) — რეკურსიული ფონის სიღრმე n-ის შესაბამისად
defrintMove(fr, to):
    print('move from ' + str(fr) + ' to ' + str(to))

def Towers(n, fr, to, spare):
    if n == 1:
        printMove(fr, to)
    else:
        Towers(n-1, fr, spare, to)
        Towers(1, fr, to, spare)
        Towers(n-1, spare, to, fr)

Towers(4, 3, 2, 1)

# ==============================================================================
# 6. ფიბონაჩი - რეკურსიული მიდგომა
# Time complexity: O(2^n) — ორი რეკურსიული ზარი თითოეულ ნაბიჯზე
# Space complexity: O(n) — რეკურსიული ფონის სიღრმე n-ის მიხედვით

def fib(x):
    if x == 0 or x == 1:
        return 1
    else:
        return fib(x-1) + fib(x-2)

print(fib(6))

# ==============================================================================
# 7. პალინდრომი - რეკურსიული შემოწმება
# Time complexity: O(n) — n არის სიტყვის სიგრძე
# Space complexity: O(n) — რეკურსიული ფონის სიღრმე და ქვეწარმავლების სიმრავლე

def isPalindrome(s):

    def toChars(s):
        s = s.lower()
        ans = ''
        for c in s:
            if c in 'abcdefghijklmnopqrstuvwxyz':
                ans += c
        return ans

    def isPal(s):
        if len(s) <= 1:
            return True
        else:
            return s[0] == s[-1] and isPal(s[1:-1])

    return isPal(toChars(s))

print(isPalindrome("abba"))

# ==============================================================================
# 8. სტრინგის უკუსვლა - რეკურსიული მიდგომა
# Time complexity: O(n^2) — სტრინგის დაჭრა new string-ების გამო თითოეულ რეკურსიულ კოდში
# Space complexity: O(n^2) — ახალი სტრინგების ასლებით, და რეკურსიული ფონის გამო

def reverse_string(s):
    if len(s) <= 1:
        return s
    return s[-1] + reverse_string(s[:-1])

print(reverse_string("hello"))  

# ==============================================================================
# 9. მაქსიმალური ელემენტის პოვნა სიაში - რეკურსიული მიდგომა
# Time complexity: O(n) — ყოველი ელემენტი ერთჯერადი შედარება
# Space complexity: O(n) — რეკურსიული ფონის სიღრმე n-ის შესაბამისად

def find_max(lst):
    if len(lst) == 1:
        return lst[0]
    return max(lst[0], find_max(lst[1:]))

print(find_max([3, 1, 7, 9, 2]))  

# ==============================================================================
# 10. ციფრთა ჯამის გამოთვლა რიცხვში - რეკურსიული მიდგომა
# Time complexity: O(log n) — n-ის ციფრთა რაოდენობის მიხედვით (მაგ: 1234-4 ციფრია)
# Space complexity: O(log n) — რეკურსიული სიღრმე ციფრთა რაოდენობით

def digit_sum(n):
    if n == 0:
        return 0
    return n % 10 + digit_sum(n // 10)

print(digit_sum(1234))  

# ==============================================================================
# 11. ელემენტის ძებნა სიაში - რეკურსიული მიდგომა
# Time complexity: O(n) — სიაში ელემენტის ძებნა რიგითი გაჩერებით
# Space complexity: O(n) — რეკურსიული ფონის სიღრმე n-ის შესაბამისად

def search_element(lst, target):
    if not lst:
        return False
    if lst[0] == target:
        return True
    return search_element(lst[1:], target)
print("search an eelemnet ")
print(search_element([1, 2, 3, 4, 5], 3)) 
print(search_element([1, 2, 3, 4, 5], 6)) 
print("-------")

# ==============================================================================
# 12. სიის დალაგების შემოწმება - რეკურსიული მიდგომა
# Time complexity: O(n) — ელემენტების წყვილებად შედარება
# Space complexity: O(n) — რეკურსიული სიღრმე n-ის მიხედვით

def is_sorted(lst):
    if len(lst) <= 1:
        return True
    return lst[0] <= lst[1] and is_sorted(lst[1:])

print(is_sorted([1, 2, 3, 4, 5])) 
print(is_sorted([1, 3, 2, 4, 5])) 

===================================================================================
l1 = [3,5,6,7,3,2,2334,5667]
l2 = [3,2,4,5,67,8,9,35,5]

# 1. სუბსეტის შემოწმება - isSubset(L1, L2)
# გადამოწმება, ხომ არის თუ არა L1-ის ყველა ელემენტი L2-ში
# დროითი სირთულე: O(n * m), სადაც n = len(L1), m = len(L2) — იმიტომ, რომ თითოეულ ელემენტს L1-იდან ვეძებთ L2-ში
# მეხსიერების სირთულე: O(1) — დამატებითი სტრუქტურა არ გამოიყენება, მხოლოდ ადგილობრივი ცვლადები

def isSubset(L1, L2):
    for el in L1:
        matched = False
        for e2 in L2:
            if el == e2:
                matched = True
                break
        if not matched:
            return False
    return True

print(isSubset(l1,l2))  # False

# ==========================================================================
# 2. ორი სიას შორის შეხების (intersection) პოვნა - intersect(L1, L2)
# ფრჩხილებში საერთო ელემენტების სია (უნიკალური ელემენტები)
# დროითი სირთულე: O(n * m + k^2) — n = len(L1), m = len(L2), k — tmp-ს ზომა
# (შეიცავს ლუწ სიის შემოწმებას დამტვირტული ელემენტებისთვის)
# მეხსიერების სირთულე: O(k) — tmp და res სიის შენახვისთვის

def intersect(L1, L2):
    tmp = []
    for el in L1:
        for e2 in L2:
            if el == e2:
                tmp.append(el)

    res = []
    for e in tmp:
        if not (e in res):
            res.append(e)

    return res

print(intersect(l1,l2))  # [3, 5, 2]

# ==========================================================================
# 3. მინიმალური და მაქსიმალური ელემენტების პოვნა სიაში - find_min_max(A)
# დროითი სირთულე: O(n) — თითოეული ელემენტის შემოწმება
# მეხსიერების სირთულე: O(1) — მხოლოდ 2 ცვლადის შენახვა

def find_min_max(A):
    min_elem = A[0]
    max_elem = A[0]

    for elem in A:
        if elem < min_elem:
            min_elem = elem
        if elem > max_elem:
            max_elem = elem

    return min_elem, max_elem

print(find_min_max(l1))  # (2, 5667)

==========================================================================================
import math

# 1. იტერაციული ორობითი ძებნა (Iterative Binary Search)
# დროითი სირთულე: O(log n) — ყოველი ნაბიჯი სიას უყოფს ნახევარამდე
# მეხსიერების სირთულე: O(1) — დამატებითი მეხსიერება არ გამოიყენება
'''
def binarySearch(arr, low, high, x):
    while low <= high:
        mid = low + (high - low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1

if __name__ == '__main__':
    arr = [2, 3, 4, 10, 40]
    x = 10
    result = binarySearch(arr, 0, len(arr) - 1, x)
    if result != -1:
        print("Element is present at index", result)
    else:
        print("Element is not present in array")
'''
# =======================================================================
# 2. რეკურსიული ორობითი ძებნა (Recursive Binary Search)
# დროითი სირთულე: O(log n)
# მეხსიერების სირთულე: O(log n) — რეკურსიული სტეკის გამო
'''
def binarySearch(arr, low, high, x):
    if high >= low:
        mid = low + (high - low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binarySearch(arr, low, mid - 1, x)
        else:
            return binarySearch(arr, mid + 1, high, x)
    else:
        return -1

if __name__ == '__main__':
    arr = [2, 3, 4, 10, 40]
    x = 10
    result = binarySearch(arr, 0, len(arr) - 1, x)
    if result != -1:
        print("Element is present at index", result)
    else:
        print("Element is not present in array")
'''
# ==================================================================================================
# 3. ყველა ქვესიმრავლეთა გამოტანა (Print all subsets) - იტერაციული მიდგომა
# დროითი სირთულე: O(n * 2^n) — 2^n ქვესიმრავლეები და თითოეულში n ელემენტი შეიძლება გამოიტანოს
# მეხსიერების სირთულე: O(n) — ერთ რიგში დასაბეჭდად

def printPowerSet(set, set_size):
    pow_set_size = (int)(math.pow(2, set_size))

    for counter in range(0, pow_set_size):
        for j in range(0, set_size):
            if ((counter & (1 << j)) > 0):
                print(set[j], end="")
        print("")

set = ['a', 'b', 'c', 'd']
printPowerSet(set, 4)

# ==================================================================================================
# 4. ყველა ქვესიმრავლეთა პოვნა (Generate all subsets) - რეკურსიული მიდგომა
# დროითი სირთულე: O(n * 2^n) — ყველა ქვესიმრავლის გენერირება და შეკრება
# მეხსიერების სირთულე: O(n * 2^n) — ყველა ქვესიმრავლის შენახვა სიაში
'''
def genSubsets(L):
    res = []
    if len(L) == 0:
        return [[]]  # ცარიელი სიის სია
    smaller = genSubsets(L[:-1])  # ყველა ქვემონაცემი ბოლო ელემენტის გარეშე
    extra = L[-1:]  # მხოლოდ ბოლო ელემენტი
    new = []
    for small in smaller:
        new.append(small + extra)  # ყველა მცირე შედეგისთვის, დაამატე ბოლო ელემენტი
    return smaller + new  # გააერთიანე შედეგები

print(genSubsets(['a', 'b']))
'''
# =============================================================================================================================
# 1. ინსर्शन სორტი (Insertion Sort)
# აღწერა:
# იწოდება "ჩასმა დალაგებულ სუბლისტში" - თითოეულ ელემენტს ჯამში ამატებს და საჭიროებისამებრ გადაადგილებს
# დროითი სირთულე:
#   უარეს შემთხვევაში: O(n²) — როცა სია უკუღმა დალაგებულია და ბევრი გადატანა ხდება
#   საუკეთესო შემთხვევაში: O(n) — როცა სია თითქმის დალაგებულია
# მეხსიერების სირთულე: O(1) 

def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # გადავიტანოთ იმ ელემენტები, რომლებიც key-ზე დიდია, ერთი პოზიციით მარჯვნივ
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# ======================================================================================
# 2. მერჯ სორტი (Merge Sort)
# აღწერა:
# "განაწილებისა და დამუშავების" ალგორითმი - ჩამოყოფს მასივს, რეკურსიულად ასორტირებს და შემდეგ აურევს
# დროითი სირთულე:
#   საშუალო და უარეს შემთხვევაში: O(n log n)
# მეხსიერების სირთულე:
#   O(n) — დამატებითი მასივების შესაქმნელად (left_half, right_half)

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        # ორი სუბლისტის ერთიანი დალაგება
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        # დარჩენილი ელემენტების ასლის გადატანა
        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

# ===== ტესტირება =====
test_arr = [38, 27, 43, 3, 9, 82, 10]
print("მერჯ სორტამდე:", test_arr)
merge_sort(test_arr)
print("მერჯ სორტის შემდეგ:", test_arr)
print("\n" + "-"*40 + "\n")

arr = [12, 11, 13, 5, 6]
print("ინსერშენ სორტამდე:", arr)
insertionSort(arr)
print("ინსერშენ სორტის შემდეგ:", arr)

# ==================================================================================================
QuickSort 
არის: დალაგების ალგორითმი. იყენებს Divide and Conquer მიდგომას.
ლოგიკა: ირჩევს ერთ ელემენტს (Pivot) და ანაცვლებს მასივში ისე, რომ Pivot-ზე პატარა ყველა ელემენტი მარცხნივ მოთავსდეს,ხოლო დიდი — მარჯვნივ. შემდეგ რეკურსიულად იგივეს აკეთებს მარცხენა და მარჯვენა ქვე-მასივებზე.
Pivot (თუ კონკრეტულად გეკითხებიან):
ლომუტოს სქემა: Pivot-ად იღებს ბოლო ელემენტს.
ჰოარის სქემა: Pivot-ად იღებს პირველ ელემენტს.
ტრეისინგის პრინციპი: დაფიქსირე Pivot.განაცვლე მასივი Pivot-ის გარშემო (Partition). დაიწყერეკურსიული გამოძახებები ახლად შექმნილ ქვე-მასივებზე.
დროითი სირთულე:
საშუალო: O(n log n)
უარეს შემთხვევაში: O(n²) (პივოტის ცუდი არჩევის გამო)
მეხსიერების სირთულე:
O(log n) — რეკურსიული კალმით (სტეკის სიღრმე)
----------------------------------------------------------------------------------------------------------------------------------
Merge Sort
არის: დალაგების ალგორითმი. ასევე იყენებს Divide and Conquer მიდგომას.
ლოგიკა:Divide-მასივი რეკურსიულად იყოფა ორ ნაწილად, სანამ არ მიიღება ერთელემენტიანი სიები.
Conquer-შემდეგ, დალაგებულ ერთელემენტიან სიებს აერთიანებს (Merges) წყვილ-წყვილად, თანამიმდევრულად ლაგდება.
ყოველთვის O(n log n)
მეხსიერების სირთულე:
O(n) — დამატებითი მასივების გამო (left და right subarrays)
----------------------------------------------------------------------------------------------------------------------------------
Towers of Hanoi
არის: რეკურსიული თავსატეხი დისკების გადასატანად.
ლოგიკა: Nდისკის A-დან C-ზე გადატანა დაიყვანება სამ რეკურსიულ ამოცანაზე
გადაიტანე N-1 დისკი წყაროდან დამხმარეზე.
გადაიტანე მე-N დისკი წყაროდან დანიშნულებაზე.
გადაიტანე N-1 დისკი დამხმარედან დანიშნულებაზე.
O(2^n) — ექსპონენციალური, დისკების რაოდენობის ზრდასთან ერთად
მეხსიერების სირთულე:
O(n) — რეკურსიული სტეკის სიღრმე
----------------------------------------------------------------------------------------------------------------------------------
Binary Search
არის:ელემენტის ძალიან სწრაფი პოვნა დალაგებულ სიაში.
ლოგიკა:შედარებულია შუა ელემენტთან (mid).
თუ ვერ მოიძებნა, ძიება გრძელდება მხოლოდ მარცხენა ან მარჯვენა ნახევარში.
O(log n) — ყოველი ნაბიჯი ნახევარს აქრობს სიიდან
მეხსიერების სირთულე:
იტერაციული: O(1)
რეკურსიული: O(log n) — რეკურსიული კალმით
----------------------------------------------------------------------------------------------------------------------------------
fibonacci
არის:ეკურსიული ფუნქცია N-ური წევრის საპოვნელად.
ლოგიკა ოველი წევრი არის წინა ორი წევრის ჯამი (F(n) = F(n-1) + F(n-2)).
საბაზისო შემთხვევები:უნქციის შეჩერება ხდება, როდესაც N=0 ან N=1  ორივე აბრუნებს 1-ს.
სირთულე (რეკურსიული)O(2^N)(ექსპონენციალური). არაეფექტურია, რადგან ერთი და იგივე ქვედა ამოცანები მრავალჯერ მეორდება (მაგ. fib(2) გამოითვლება რამდენჯერმე).
დროითი სირთულე:
O(2^n) — ექსპონენციალური, ბევრჯერ განმეორებადი გამოთვლების გამო
მეხსიერების სირთულე:
O(n) — რეკურსიული სტეკის სიღრმე
----------------------------------------------------------------------------------------------------------------------------------
isPalindrome(s)	პალინდრომი	წმენდს სტრიქონს და რეკურსიულად ამოწმებს ემთხვევა თუ არა პირველი და ბოლო სიმბოლოები
რეკურსიული შემოწმება:იყენებს ორ ეტაპს 1 სტრიქონის გაწმენდა (მხოლოდ ასოები, მცირე ასოებით) 2 რეკურსიული შემოწმება.
საბაზისო შემთხვევა	len(s) <= 1 (აბრუნებს True).
დროითი სირთულე:
O(n²) — სტრინგის ყოველრეკურსიულ გამოძახებასთან ერთად ახალი სტრინგის შექმნა (s[1:-1])
(თუ ოპტიმიზირებულ ალგორითმს არ გამოვიყენებთ)
მეხსიერების სირთულე:
O(n²) — ასევე ახალ სტრინგებს აშენებს თითოეულ რექურსიულ დონეზე